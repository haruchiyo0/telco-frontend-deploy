const axios = require('axios');
const { Recommendation, Product, UserBehavior } = require('../models');

// 1. API GENERATE REKOMENDASI (Fitur Baru: a, b, c)
// Ini yang dipakai tombol "Cek Penawaran"
exports.generateRecommendation = async (req, res) => {
    try {
        const userId = req.user.id;

        // Ambil Data Kebiasaan User
        const behavior = await UserBehavior.findOne({ where: { userId } });
        
        // Handle jika data user tidak ada
        if (!behavior) {
            return res.status(404).json({ message: "Data behavior user belum tersedia. Silakan register ulang." });
        }

        // Payload untuk ML
        const mlPayload = {
            avg_data_usage: behavior.avg_data_usage_gb,
            topup_freq: behavior.topup_freq,
            monthly_spend: behavior.monthly_spend,
            roaming_usage: behavior.roaming_usage ? 1 : 0,
            streaming_usage: behavior.pct_video_usage,
            gaming_usage: behavior.gaming_usage
        };

        // URL Server ML (Aila)
        const ML_URL = 'https://telco-ml-engine-production.up.railway.app/predict'; 
        
        let recommendedProductIds = [];

        // Handle ML Error (Fallback)
        try {
            const response = await axios.post(ML_URL, mlPayload);
            recommendedProductIds = response.data.recommendations; 
        } catch (mlError) {
            console.error("ML Service Error (Fallback Mode):", mlError.message);
            recommendedProductIds = [1, 2]; // Produk default jika ML mati
        }

        // Simpan History ke Database
        try {
            await Recommendation.create({
                userId: userId,
                productId: recommendedProductIds[0], // Simpan ID produk pertama
                score: 0.99,
                reason: "Generated by System"
            });
        } catch (dbError) {
            console.error("Gagal simpan history:", dbError.message);
        }

        // Ambil Detail Produk untuk ditampilkan
        const products = await Product.findAll({
            where: { id: recommendedProductIds }
        });

        res.json({
            status: 'success',
            source: recommendedProductIds.length === 2 && recommendedProductIds[0] === 1 ? 'Fallback' : 'ML',
            data: products
        });

    } catch (error) {
        res.status(500).json({ message: "Server Error: " + error.message });
    }
};

// Tambahkan function baru di bawah generateRecommendation
exports.checkAndGenerateIfEmpty = async (req, res) => {
    try {
        const userId = req.user.id;

        // Cek apakah sudah ada recommendations
        const existing = await Recommendation.findAll({
            where: { userId },
            include: [{ model: Product, as: 'product' }]
        });

        // Jika ada, return langsung
        if (existing.length > 0) {
            return res.json({
                status: 'success',
                hasRecommendations: true,
                data: existing
            });
        }

        // Jika kosong, trigger ML generation
        console.log(`ðŸ¤– Generating ML recommendations for user ${userId}`);

        const behavior = await UserBehavior.findOne({ where: { userId } });
        
        if (!behavior) {
            return res.status(404).json({
                status: 'error',
                message: 'User behavior data not found'
            });
        }

        const mlPayload = {
            avg_data_usage: behavior.avg_data_usage_gb,
            topup_freq: behavior.topup_freq,
            monthly_spend: behavior.monthly_spend,
            roaming_usage: behavior.roaming_usage ? 1 : 0,
            streaming_usage: behavior.pct_video_usage,
            gaming_usage: behavior.gaming_usage
        };

        const ML_URL = 'https://telco-ml-engine-production.up.railway.app/predict';
        
        let recommendedProductIds = [];

        try {
            const response = await axios.post(ML_URL, mlPayload, { timeout: 25000 });
            recommendedProductIds = response.data.recommendations;
        } catch (mlError) {
            console.error("ML Service Error:", mlError.message);
            recommendedProductIds = [1, 2]; // Fallback
        }

        // Simpan ke database
        for (const productId of recommendedProductIds.slice(0, 3)) {
            await Recommendation.create({
                userId,
                productId,
                score: 0.95,
                reason: "AI-powered recommendation"
            });
        }

        // Fetch yang baru disimpan
        const newRecommendations = await Recommendation.findAll({
            where: { userId },
            include: [{ model: Product, as: 'product' }]
        });

        res.json({
            status: 'success',
            hasRecommendations: true,
            justGenerated: true,
            data: newRecommendations
        });

    } catch (error) {
        console.error('Error in checkAndGenerateIfEmpty:', error);
        res.status(500).json({ 
            status: 'error',
            message: error.message 
        });
    }
};
// 2. API GET MY RECOMMENDATIONS (Fitur Lama: Restore)
// Fungsi ini WAJIB ADA karena dipanggil oleh routes.js di baris 10
exports.getMyRecommendations = async (req, res) => {
    try {
        const userId = req.user.id;

        const recommendations = await Recommendation.findAll({
            where: { userId: userId },
            include: [
                { model: Product, as: 'product' }
            ],
            order: [['createdAt', 'DESC']]
        });

        res.json({
            status: 'success',
            data: recommendations
        });
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};

// 3. API CREATE RECOMMENDATION (Fitur Lama: Restore)
// Jaga-jaga jika route POST lama masih ada yang pakai
exports.createRecommendation = async (req, res) => {
    try {
        const { userId, productId, score, reason } = req.body;
        const newRec = await Recommendation.create({ userId, productId, score, reason });
        res.status(201).json({ status: 'success', data: newRec });
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};